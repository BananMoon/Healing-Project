## 1️⃣ 디폴트 메서드의 등장
- 자바 8에서는 **기본 구현을 포함하는 인터페이스를 정의**하는 2가지 방법을 제공한다.
- 만약 인터페이스가 변경이 되면, 해당 인터페이스를 구현한 모든 클래스의 구현도 고쳐야하는 상황이 온다면 매우 당황스러울 것이다.
  이 문제점을 자바8에서 제공된 새로운 기능으로 해결할 수 있다. 
- 디폴트 메서드는 인터페이스에 메소드를 기본 구현할 수 있도록 한다.

> 원래 인터페이스는 추상 클래스보다 추상화 정도가 높아 body를 가진 일반 메서드와 멤버변수를 가질 수 없고 기능을 명시적으로 선언하는 역할만을 하였다. 
자바 8에서는 메서드 구현을 포함하는 인터페이스를 정의할 수 있다.
<br>

결과적으로 기존 인터페이스를 구현하는 클래스는 자동으로 인터페이스에 추가된 새로운 메서드인 디폴트 메서드를 상속받게 된다.<br>
➡️ 기존의 코드 구현을 바꾸지 않고 인터페이스를 바꿀 수 있다.<br>
➡️ 디폴트 메서드나 정적메서드가 추가되면 해당 인터페이스를 구현하던 모든 클래스가 이 메서드들을 구현할 필요없이 접근이 가능하다는 사실이다.<br>
 (인터페이스를 구현하는 클래스가 디폴트 메서드를 구현하지 않은 경우 인터페이스 자체에서 기본으로 제공한다.)<br>
<br>

디폴트 메서드를 이용하면 인터페이스의 기본 구현을 그대로 상속하므로 인터페이스에 자유롭게 (수정 걱정 없이) 새 메서드를 추가할 수 있다.
<br>

인터페이스 A와 이를 구현하는 클래스 B가 있다. 인터페이스 A에 setUsername() 메서드를 추가했다 해보자.<br>
인터페이스 A에 변경이 일어났지만 클래스 B에 setUsername() 메서드를 구현하지 않는다.<br>

**왜?** 인터페이스에 새로운 메서드를 추가하더라도 **바이너리 호환성은 유지**된다. 즉, 새로 추가된 메서드를 B가 호출하지만 않으면 새로운 메서드를 구현하지 않아도
기존의 클래스 파일 구현으로 잘 동작한다는 의미이다. *하지만,* 클래스 B에 구현되지않은 setUsername() 메서드를 어디선가 호출하면 런타임 에러가 발생한다.<br>
또한, 전체 애플리케이션을 재빌드하여도 에러가 발생한다. (클래스 B에 setUsername() 메서드가 구현되지 않았으므로)

<br>
이 문제 또한 디폴트 메서드가 해결한다. 디폴트 메서드를 이용해서 API를 바꾸면 새롭게 바뀐 인터페이스에서 자동으로 기본 구현을 제공하므로 기존 코드를 고치지 않아도 된다.
<br>

## 2️⃣ 디폴트 메서드의 정의
- default 키워드로 시작하며 다른 클래스에 선언된 메서드처럼 **바디를 포함**한다.
- 접근제어자가 public이며 생략 가능하다.
- 인터페이스에 이미 구현되어 있어 인터페이스를 구현한 클래스에서 코드를 구현할 필요가 없다. (단, 구현하는 클래스에서 재정의할 수 있다.)
```java
    public interface Calculator {
        public int plus(int i, int j);
        public int multiple(int i, int j);
        default int exec(int i, int j){      //default 키워드와 함께 메소드 구현 가능
            return i + j;
        }
    }

    //Calculator인터페이스를 구현한 MyCalculator클래스
    public class MyCalculator implements Calculator {

        @Override
        public int plus(int i, int j) {
            return i + j;
        }

        @Override
        public int multiple(int i, int j) {
            return i * j;
        }
    }

    public class MyCalculatorExam {
        public static void main(String[] args){
            Calculator cal = new MyCalculator();  // 구현 클래스를 통해 인스턴스 생성 가능.
            int value = cal.exec(5, 10);    // 따로 구현 클래스에서 오버라이드하지않아도 기본 구현 제공됨.
            System.out.println(value);
        }
    }
```
<br>

## 3️⃣ 디폴트 메서드의 활용, 동작 다중 상속
- 디폴트 메서드를 사용하면 기존에는 불가능했던 동작 다중 상속 기능도 구현할 수 있다.
- 인터페이스가 구현을 포함할 수 있으므로 클래스는 여러 인터페이스에서 **동작을 상속**받을 수 있다.
